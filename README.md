# SimpleNavigator (Linux, Mac)

Реализация проекта Simple Navigator.

В рамках данного задания все графы должны удовлетворять следующим требованиям:
- Веса ребер только натуральными числами
- Могут быть петли
- Веса могут отличаться на всех ребрах
- Только ненулевой связный граф

## Обход графа в глубину и в ширину

Реализовал библиотеку _s21_graph.h_:
* Библиотека разработана на языке С++
* Код библиотеки находится в папке src
* При написании кода придерживался Google Style
* Оформил решение как статическую библиотеку
* Библиотека представлена в виде класса `Graph`, который хранит в себе информацию о графе с помощью **матрицы смежности**. Размерность матрицы смежности задается динамически при инициализации графа (при его загрузке из файла)
* Сборка программы настроена с помощью Makefile со стандартным набором целей для GNU-программ: _all, clean, test, graph.a_
* Обеспечено полное покрытие unit-тестами методов класса `Graph`
* Класс `Graph` содержит в себе следующие публичные методы:
    + `LoadGraphFromFile(string filename)` - загрузка графа из файла в формате матрицы смежности
    + `ExportGraphToDot(string filename)` - выгрузка графа в файл в формате dot

Реализовал библиотеку _graph_algorithms.h_
* Библиотека разработана на языке С++
* Код библиотеки находится в папке src
* Оформил решение как статическую библиотеку
* Библиотека представлена в виде класса `GraphAlgorithms`, который содержит в себе реализацию алгоритмов на графах
* Добавил в Makefile цель _graph_algorithms.a_
* Обеспечено полное покрытие unit-тестами методов класса `GraphAlgorithms`
* Класс `GraphAlgorithms` содержит в себе следующие публичные методы:    
    + `DepthFirstSearch(Graph &graph, int start_vertex)` - *нерекурентный* поиск в глубину в графе от заданной вершины
    + `BreadthFirstSearch(Graph &graph, int start_vertex)` - поиск в ширину в графе от заданной вершины
* Использовал *самописные* вспомогательные классы `Stack` и `Queue`. Эти классы содержат в себе следующие методы:
    + `stack()` - создание пустого стека
    + `queue()` - создание пустой очереди
    + `push(value)` - добавление элемента в стек/очередь
    + `pop()` - получение элемента из стека/очереди с его последующим удалением из стека/очереди
    + `top()` - получение элемента из стека без его удаления из стека
    + `front()` - получение первого элемента из очереди без его удаления из очереди
    + `back()` - получение последнего элемента из очереди без его удаления из очереди

## Поиск кратчайших путей в графе

* Добавил в класс `GraphAlgorithms` два метода:
    + `GetShortestPathBetweenVertices(Graph &graph, int vertex1, int vertex2)` - поиск кратчайшего пути между двумя вершинами в графе с использованием *алгоритма Дейкстры*. Функция принимает на вход номера двух вершин и возвращает численный результат, равный наименьшему расстоянию между ними
    + `GetShortestPathsBetweenAllVertices(Graph &graph)` - поиск кратчайших путей между всеми парами вершин в графе с использованием *алгоритма Флойда-Уоршелла*. В качестве результата функция возвращает матрицу кратчайших путей между всеми вершинами графа

## Поиск минимального остовного дерева

* Добавил в класс `GraphAlgorithms` метод:
    + `GetLeastSpanningTree(Graph &graph)` - поиск наименьшего остовного дерева в графе с помощью *алгоритма Прима*. В качестве результата функция возвращает матрицу смежности для минимального остовного дерева

## Задача коммивояжера

* Добавил в класс `GraphAlgorithms` метод:
    + `SolveTravelingSalesmanProblem(Graph &graph)` - решение задачи коммивояжера с помощью *муравьиного алгоритма*. Необходимо найти самый выгодный (короткий) маршрут, проходящий через все вершины графа хотя бы по одному разу с последующим возвратом в исходную вершину. В качестве результата функция возвращает структуру `TsmResult`, описанную ниже:
    ```cpp
    struct TsmResult {
        std::vector<int> vertices;    // массив с искомым маршрутом (с порядком обхода вершин)
        double distance;  // длина этого маршрута
    }
    ``` 

*Если при заданном графе решение задачи невозможно, выводится ошибка.*

## Консольный интерфейс

* Написал основную программу, которая представляет из себя консольное приложение для проверки работоспособности реализованных библиотек graph.h и graph_algorithms.h
* Консольный интерфейс покрывает следующий функционал:
    1. загрузка исходного графа из файла
    2. обход графа в ширину с выводом результата обхода в консоль
    3. обход графа в глубину с выводом результата обхода в консоль
    4. поиск кратчайшего пути между произвольными двумя вершинами с выводом результата в консоль
    5. поиск кратчайших путей между всеми парами вершин в графе с выводом результирующей матрицы в консоль
    6. поиск минимального остовного дерева в графе с выводом результирующей матрицы смежности в консоль
    7. решение задачи комивояжера с выводом результирующего маршрута и его длины в консоль
